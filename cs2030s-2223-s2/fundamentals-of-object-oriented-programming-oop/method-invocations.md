---
description: Overriden and overloaded methods make programmers go crazy.
---

# Method Invocations

Although polymorphism and OOP in general is a very powerful tool in building abstractions, it forces the Java compiler to think much harder when it comes to **method invocation**, i.e, choosing the correct method to be applied in the program. The Java compiler decides which method to use in a two-step process.

1. Compilation Time. Java uses the compile-time type of the target to determine the method descriptor of the method invoked. The compiler first searches for all methods that can be correctly invoked on the given argument. When there are multiple methods that can correctly accept the argument, we choose the most **specific** method. We say that a method `M` is more specific than a method `N` if the arguments of `M` can be passed to `N` without error. Finally, the method descriptor is stored in the generated bytecode.
2. Run Time. During runtime, the method descriptor from the first step is retrieved. The run-time type of the target is then determined. Suppose the run-time type of the target is `R`. Java first looks for an accessible method with a matching descriptor in `R`, before proceeding up the class hierarchy till `Object`. The first method implementation with a matching method descriptor found will be the method that is executed.

This description only applies to instance methods, as class methods do not support dynamic binding. For class methods, the method to invoke is resolved statically during compile time. The same process in the first step is taken, but the corresponding method implementation will always be executed during run-time, without considering the run-time type of the target.
